package prob0036

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

func Test_isValidSudoku(t *testing.T) {
	ast := assert.New(t)

	// test case
	tcs := []struct{
		input [][]byte
		ans bool
	}{
		{
			[][]byte{
				[]byte{'5','3','.','.','7','.','.','.','.'},
				[]byte{'6','.','.','1','9','5','.','.','.'},
				[]byte{'.','9','8','.','.','.','.','6','.'},
				[]byte{'8','.','.','.','6','.','.','.','3'},
				[]byte{'4','.','.','8','.','3','.','.','1'},
				[]byte{'7','.','.','.','2','.','.','.','6'},
				[]byte{'.','6','.','.','.','.','2','8','.'},
				[]byte{'.','.','.','4','1','9','.','.','5'},
				[]byte{'.','.','.','.','8','.','.','7','9'},
			},true,
		},
		{
			[][]byte{
				[]byte{'5','3','.','.','7','.','.','.','.'},
				[]byte{'6','.','.','1','9','5','.','.','.'},
				[]byte{'.','9','8','.','.','.','.','6','.'},
				[]byte{'5','.','.','.','6','.','.','.','3'},
				[]byte{'4','.','.','8','.','3','.','.','1'},
				[]byte{'7','.','.','.','2','.','.','.','6'},
				[]byte{'.','6','.','.','.','.','2','8','.'},
				[]byte{'.','.','.','4','1','9','.','.','5'},
				[]byte{'.','.','.','.','8','.','.','7','9'},
			},false,
		},
		{
			[][]byte{
				[]byte{'5','3','.','.','7','.','.','.','.'},
				[]byte{'6','.','.','1','9','5','.','.','.'},
				[]byte{'.','9','8','.','.','.','.','6','.'},
				[]byte{'8','.','.','.','6','.','.','.','3'},
				[]byte{'4','.','.','8','.','3','.','.','1'},
				[]byte{'7','.','.','.','2','.','.','.','6'},
				[]byte{'.','6','.','.','.','.','2','8','.'},
				[]byte{'.','.','.','4','1','9','.','.','9'},
				[]byte{'.','.','.','.','8','.','.','7','9'},
			},false,
		},
	}

	for _, tc := range tcs {
		fmt.Printf("~~%v~~\n", tc)

		ast.Equal(tc.ans, isValidSudoku(tc.input), "输入:%v", tc)
	}
}

func Benchmark_isValidSudoku(b *testing.B) {
	type args struct {
		board [][]byte
	}
	tests := []struct {
		name string
		args [][]byte
		want bool
	}{
		// TODO: Add test cases.
		{
			args: [][]byte{
				[]byte{'5','3','.','.','7','.','.','.','.'},
				[]byte{'6','.','.','1','9','5','.','.','.'},
				[]byte{'.','9','8','.','.','.','.','6','.'},
				[]byte{'8','.','.','.','6','.','.','.','3'},
				[]byte{'4','.','.','8','.','3','.','.','1'},
				[]byte{'7','.','.','.','2','.','.','.','6'},
				[]byte{'.','6','.','.','.','.','2','8','.'},
				[]byte{'.','.','.','4','1','9','.','.','5'},
				[]byte{'.','.','.','.','8','.','.','7','9'},
			},
			want: true,
		},
	}

	for _, tt := range tests {

		b.Run("isValidOptimize", func(b *testing.B) {
			seen := make(map[string]bool)
			for i := 0; i < 9; i++ {
				for j := 0; j < 9; j++ {
					isValidOptimize(&tt.args, i, j, seen)
				}
			}

		})

		b.Run("isValid", func(b *testing.B) {
			for i := 0; i < 9; i++ {
				for j := 0; j < 9; j++ {
					isValid(&tt.args, i, j)
				}
			}

		})
	}
}